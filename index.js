// vim: set ts=4

const ANS_EXP = 8; // s
const INTRO_DELAY = 20; // s
const VIGVAM_ID = -158775326;

require('dotenv').config(); // load BOT_TOKE from .env file

const Telegraf = require('telegraf');
const { Extra, Markup } = require('telegraf');
const TOKEN = null;
const token = process.env.BOT_TOKEN || TOKEN;

const util = require('util');
const child_process = require('child_process');
const exec = util.promisify(child_process.exec.bind(child_process));
const getLightStatus = () => exec('gpio -1 read 22').then(l => parseInt(l, 10));
const throttle = require('lodash.throttle');
const debounce = require('just-debounce-it');
const randList = (list) => list[Math.floor(Math.random() * list.length)];
const edit = (repCtx, txt) => app.telegram.editMessageText(repCtx.chat.id, repCtx.message_id, null, txt);
const typing = (ctx) => app.telegram.sendChatAction(ctx.chat.id, 'typing').catch(e=>console.error('e', e));

const app = new Telegraf(token);

app.telegram.getMe().then((botInfo) => {
  app.options.username = botInfo.username
});

let homemates = {
	list: {
		lenya: { presense: null, name: '–õ—ë–Ω—è', id: 234091889 },
		misha: { presense: null, name: '–ú–∏—à–∞', id: 210367273 },
		sasha: { presense: null, name: '–°–∞–Ω—è', id: 147445817 },
	},
	get: function (key, field) { return this.list[key.toLowerCase()] && this.list[key.toLowerCase()][field]; },
	set: function (key, field, val) { this.list[key][field] = val; return val; },
	setAll: function (field, object) { Object.keys(this.list).forEach((key) => {this.set(key, field, object[key]);}); },
	empty: function () { return Object.keys(this.list).every(key => !this.get(key, 'presense')); },
	isMember: function (id) { Object.keys(this.list).some(key => this.get(key, 'id') === id); },
}

const onChange = (type, signal, data) => {
	switch(type) {
	case('home'):
		switch(signal) {
		case('presense'):
			if (data.sasha && data.sasha.before) getLightStatus().then(v=>{if(v.trim()) throw 'y'}).then(() => exec('light on')).then(() => {
				app.telegram.sendMessage(homemates.get('sasha', 'id'), 'Sasha came back ==> Light turned on');
			}).catch(() => {});
			if (data.sasha && !data.sasha.before) getLightStatus().then(v=>{if(!v.trim()) throw 'n'}).then(() => exec('light off')).then(() => {
				app.telegram.sendMessage(homemates.get('sasha', 'id'), 'Sasha left ==> Light turned off');
			}).catch(() => {});
			if (homemates.empty()) exec('has-music').then(v=>{if(!v.trim()) throw 'none'}).then(() => exec('stop-music')).then(() => {
				app.telegram.sendMessage(VIGVAM_ID, 'No body at home ==> Music stopped');
			}).catch(() => {});
		break;
		}
	break;
	}
};

let lastMessageTime = null;

const getIntro_ = debounce(() => {
	return randList(['–∞–∞–∞–∞–∞','–≤–∏–≥–≤+–∞–º–µ','–∫–∞—Ä+–æ—á','—Å–ª+—É—à–∞–π—Ç–µ','—ç—Ç —Å+–∞–º–æ–µ']) + ', ... &&& ... ‚Äî ';
}, INTRO_DELAY, true);
const getIntro = () => getIntro_() || '';

const say = (text, ctx, isQuiet, noIntro) => {
	if (!text) { console.log('—Ç—É—Ç –∏ –≥–æ–≤–æ—Ä–∏—Ç—å –Ω–µ—á–µ–≥–æ'); return;}
	console.log(">>", text.trim().replace(/\n/g, ' '))
	return exec(`tts "${ noIntro || getIntro() }, ${ text.replace(/\n/g, ' ') }"`).then((stdout) => {
		console.log('say', stdout);
		isQuiet || ctx.reply('—è –≤—Å—ë —Å–∫–∞–∑–∞–ª');
	}).catch(e => {
		console.error('say error', e);
		isQuiet || ctx.reply('–Ω–∏—à–º–∞–≥–ª–∞–∞ /');
	});
};

const whoAtHome = () => {
	return exec('who-at-home')
	.then((stdout) => {
		const j = JSON.parse(stdout)
		j.lenya = j.lenya === 'Y';
		j.misha = j.misha === 'Y';
		j.sasha = j.sasha === 'Y';
		return j;
	});
};

let isVoiceVerboseMode = false;
let _isIn1wordAnsExpecting = false;
const isIn1wordAnsExpecting = () => {
	return _isIn1wordAnsExpecting ? (Date.now() - _isIn1wordAnsExpecting < 1000 * ANS_EXP) : false;
};

const lastCommand = {
	_command: null,
	type: null,
	set: function(type, command) {
		this.type = type;
		this._command = command;
	},
	has: function () {
		return this._command;
	},
	repeat: function () {
		if (!this.has()) { console.error('hm, there is not command'); return; }
		this._command(...this._args)
	},
};

const lastQuestion = {
	_question: null,
	set: function(command) {
		this._question = (isYes) => isYes && command.repeat();
	},
	answer: function (isYes) {
		if (!this._question) { console.error('hm, there is not question'); return; }
		_isIn1wordAnsExpecting = false;
		this._question(isYes);
	}
};

const commands = {
	run: function (kind, name, ctx) {
		if (!this.accessRightsGuard()) return;
		const cmd = this.list[kind][name];
		cmd(ctx);
		lastCommand.set(cmd);
	},
	list: {
		voice: {
			voice_over: ctx => {
				isVoiceVerboseMode = true;
				ctx.reply('ok, I`ll say everything you post')
			},
		},
		music: {},
		light: {},
		misc: {},
	},
	accessRightsGuard: function (id) {
		const hasAccess = homemates.isMember(id);
		if (!hasAccess) app.telegram.sendMessage(id, '–ë–µ—Å–ø—Ä–∞–≤–Ω–∞—è —Å–∫–æ—Ç–∏–Ω–∞ –Ω–µ –º–æ–∂–µ—Ç –ø–æ–≤–µ–ª–µ–≤–∞—Ç—å –ë–æ—Ç–æ–º');
		return hasAccess;
	},
};

/*
 voice
*/

app.hears(/^(?:(—á–∏—Ç–∞–π|–∑–∞—á–∏—Ç—ã–≤–∞–π)\s+((–≤—Ö–æ–¥—è—â–∏–µ\s+)?—Å–æ–æ–±—à–µ–Ω–∏—è|—á[–∞—è]—Ç)|read\s+(chat|messages))/i, (ctx) => {
	typing(ctx);
	commands.run('voice', 'voice_over', ctx);
});
app.hears(/^(?:–Ω–µ\s+(—á–∏—Ç–∞–π|–∑–∞—á–∏—Ç—ã–≤–∞–π)\s+((–≤—Ö–æ–¥—è—â–∏–µ\s+)?—Å–æ–æ–±—à–µ–Ω–∏—è|—á[–∞—è]—Ç)|–ø–µ—Ä–µ—Å—Ç–∞–Ω—å\s+—á–∏—Ç–∞—Ç—å\s+—á[–∞—è]—Ç|no\s+read\s+(chat|messages))/i, (ctx) => {
	typing(ctx);
	isVoiceVerboseMode = false;
	ctx.reply('ok, I`ll be quiet')
});
app.hears([/^(?:say\s+((.|\n)+))/im, /^(?:—Å–∫–∞–∂–∏\s+((.|\n)+))/mi], (ctx) => {
	console.log(ctx.match);
	ctx.reply('ok, wait please');
	say(ctx.match[1], ctx);
	console.log('sent');
});


/*
 home
*/

app.hears(/^(?:who\s+(is\s+)?at\+home\??|(–≤—Å–µ|–∫—Ç–æ)\s+(–ª–∏\s+)?–¥–æ–º–∞\??)/i, (ctx) => {
	Promise.all([
		ctx.reply('10 sec, please‚Ä¶ üòÖ '),
		typing(ctx),
		whoAtHome(),
	])
	.then(([replyCtx, _, json]) => {
		const getStatus = (key) => json[key]
		? `‚úÖ ${ homemates.get(key, 'name') } ${ randList(['–¥–æ–º–∞ ', '—Ç—É—Ç–∞', '–≥–¥–µ-—Ç–æ –∑–¥–µ—Å—å']) }`
		: `üî¥ ${ homemates.get(key, 'name') } ${ key === 'lenya' ? randList(['‚Äî –ø–æ –±–∞–±–∞–º', '‚Äî –æ–ø—è—Ç—å –ø–æ –±–∞–±–∞–º']) : randList(['–Ω–µ –¥–æ–º–∞', '–æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç', '—à–ª—è–µ—Ç—Å—è']) }`
		const txt = Object.keys(homemates.list).map((key) => getStatus(key)).join('\n');
		edit(replyCtx, txt);
	});
});


/*
 light
*/

app.hears(/^(?:turn\s+light\s+on|–≤–∫–ª—é—á–∏\s+—Å–≤–µ—Ç)/i, (ctx) => {
	typing(ctx);
	exec('light on').then(() => ctx.reply('ok')).catch(() => ctx.reply('–Ω–∏—à–º–∞–≥–ª–∞–∞'));
});
app.hears(/^(?:turn\s+light\s+off|–≤—ã–∫–ª—é—á–∏\s+—Å–≤–µ—Ç)/i, (ctx) => {
	typing(ctx);
	exec('light off').then(() => ctx.reply('ok')).catch(() => ctx.reply('–Ω–∏—à–º–∞–≥–ª–∞–∞'));
});
app.hears(/^(?:is\s+light\s+on|light\s+status|–≤–∫–ª—é—á–µ–Ω(\s+–ª–∏)?\s+—Å–≤–µ—Ç|—Å–≤–µ—Ç\s+–≤–∫–ª—é—á–µ–Ω\??)/i, (ctx) => {
	typing(ctx);
	getLightStatus().then(status => {
		ctx.reply('ok: ' + (status ? 'on' : 'off'));
	}).catch(() => ctx.reply('–Ω–∏—à–º–∞–≥–ª–∞–∞'));
});

/*
 music
*/

app.hears(/^(?:(–≤—ã–∫–ª—é—á–∏|–æ—Å—Ç–∞–Ω–æ–≤–∏|–≤—ã—Ä—É–±–∏|—É–±–µ—Ä–∏)\s+(–º—É–∑—ã–∫—É|–∑–≤—É–∫))/i, (ctx) => {
	typing(ctx);
	exec('has-music').then(hasMusic => {
		if(hasMusic) {
			exec('stop-music').then((stdout) => {
				ctx.reply('ok, music stopped');
			}).catch(e => {console.error(e); ctx.reply('–Ω–∏—à–º–∞–≥–ª–∞–∞–∞');});
		} else {
			ctx.reply('–ù–∏–º–∞–≥—É—É. You can make quieter');
		}
	}).catch(e =>{console.error(e); ctx.reply('–ù–∏–º–∞–≥—É—É');});
})
app.hears(/^(?:–ø–æ—Å—Ç–∞–≤—å –Ω–∞ –ø–∞—É–∑—É|–ø–∞—É–∑–∞$|pause(,\s+please!?)?)/i, (ctx) => {
	typing(ctx);
	exec('has-music').then(hasMusic => {
		if(hasMusic) {
			exec('pause-music').then((stdout) => {
				ctx.reply('Done, music paused');
			}).catch((e) => {console.error(e); ctx.reply('I cannot :/');});
		} else {
			ctx.reply('–ù–∏–º–∞–≥—É—É. You can make quieter');
		}
	}).catch(e =>{console.error(e); ctx.reply('–ù–∏–º–∞–≥—É—É');});
})
app.hears(/^(?:–ø—Ä–æ–¥–æ–ª–∂(–∏|–∞–π)\s+(–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ|–∏–≥—Ä–∞—Ç—å)|resume\s+playing)/i, (ctx) => {
	typing(ctx);
	exec('has-music').then(hasMusic => {
		if(hasMusic) {
			exec('resume-music').then((stdout) => {
				ctx.reply('Done, music resumed');
			}).catch((e) => {console.error(e); ctx.reply('I cannot :/');});
		} else {
			ctx.reply('–ù–∏–º–∞–≥—É—É. You can make quieter');
		}
	}).catch(e =>{console.error(e); ctx.reply('–ù–∏–º–∞–≥—É—É');});
})
app.hears(/^(?:(—Å–¥–µ–ª–∞–π\s+)?(–ø–æ)?—Ç–∏—à–µ|make(\s+(sound|music))?\s+quieter)/i, (ctx) => {
	typing(ctx);
	exec('v=$(get-vol); vol $(node -p "$v - 10") quieter').then((stdout) => {
		ctx.reply(`ok, vol decreased`);
	}).catch(e =>{console.error(e); ctx.reply('–ù–∏–º–∞–≥—É—É');});
});
app.hears(/^(?:(—Å–¥–µ–ª–∞–π\s+)?(–ø–æ)?–≥—Ä–æ–º—á–µ|make(\s+(sound|music))?\s+louder)/i, (ctx) => {
	typing(ctx);
	exec('v=$(get-vol); vol $(node -p "$v + 10") quieter').then((stdout) => {
		ctx.reply(`ok, vol insreased`);
	}).catch(e =>{console.error(e); ctx.reply('–ù–∏–º–∞–≥—É—É');});
});
app.hears(/^(?:(?:(?:—Å—ã|–∏)–≥—Ä–∞–π|–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–∏|play)\s+((?:.|\n)+))/i, (ctx) => {
	console.log(ctx.match[1].trim());
	ctx.reply('ok, I`ll try')
	exec(`mplayer "${ ctx.match[1].trim() }"`).then((stdout) => {
	}).catch((e) => {
		console.error(e);
		ctx.reply('–Ω–∏—à–º–∞–≥–ª–∞–∞');
	});
});

/*
 misc
*/

app.hears(/^(?:(?:–∫–∞–∫–∞—è\s+)?–ø–æ–≥–æ–¥–∞|—á—Ç–æ\s+—Å\s+–ø–æ–≥–æ–¥–æ–π\??|—á—Ç–æ\s+–æ–±–µ—â–∞—é—Ç\??|—á—Ç–æ\s+—Å\s+–ø–æ–≥–æ–¥–æ–π\??|(?:(?:(?:say|get|read)\s+)?(?:a\s+)?weather))/i, (ctx) => {
	Promise.all([
		ctx.reply('10 sec, please‚Ä¶ üòÖ'),
		typing(ctx),
		exec(`get-weather`).then(res => JSON.parse(res)),
	])
	.then(([repCtx, _, weather]) => {
		console.log(repCtx, weather)
		const txt = weather.description && weather.temp && `–ü–æ–≥–æ–¥–∞ –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è: ${ weather.description }, ${ Math.floor(weather.temp) } –≥—Ä–∞–¥—É—Å–æ–≤`;
		edit(repCtx, txt || '–Ω–∏—à–º–∞–≥–ª–∞');
		weather.icon && app.telegram.sendPhoto(ctx.chat.id, `http://openweathermap.org/img/w/${ weather.icon }.png`, {disable_notification: true});
		return [txt, weather];
	})
	.then(([txt]) => ((new Date()).getHours() >= 9) && say(txt, ctx, true, true))
	.catch(e => {console.error(e); ctx.reply('–Ω–∏—à–º–∞–≥–ª–∞');});
});

//app.on('sticker', (ctx) => ctx.reply(''))
app.command('start', (props) => {
  const { from, reply } = props;
  console.log('start', from, props)
  return reply('Welcome!')
})
app.hears(/^hi$/i, (ctx) => ctx.reply('Hey there!'))

//app.telegram.sendMessage(VIGVAM_ID, '–ü—Ä–∏–≤–µ—Ç —á–µ–ª–æ–≤–µ–∫–∏');
//app.on('inline_query', (props) => {
//  const { inlineQuery } = props;
//  console.log('aa?', props);
//  //props.replyWithMarkdown('Hey there!');
//  //answerInputTextMessageContent([{message_text:'Hey there!'}]);
//});

/*
 universal
*/

app.hears(/^(?:–ø–æ–≤—Ç–æ—Ä–∏|((–∏|–ø–æ–≤—Ç–æ—Ä–∏)\s+)?–µ—â—ë(\s+—Ä–∞–∑)?|(one\s+more\s+time|more|repeat)(,\s+please)?)$/i, (ctx) => {
	if (!lastCommand.has()) return;
	switch(lastCommand.type) {
		// change the entity
		case('put'):
		break;
		// get the/an entity (see cacheControl)
		case('get'):
			if (lastCommand.cacheControl === 'no-cache') {
				lastCommand.repeat()
			} else {
				ctx.reply('no changes');
			}
		break;
		// create the entity
		case('post'):
			ctx.reply('are you sure, you want to repeat?')
			lastQuestion.set(lastCommand);
		break;
		// delete the/an entity (see cacheControl)
		case('delete'):
			if (lastCommand.cacheControl === 'no-cache') {
				ctx.reply('are you sure, you want to repeat?')
				lastQuestion.set(lastCommand);
			} else {
				ctx.reply('already deleted');
			}
		break;
		default: ctx.reply('I`m not sure about last command'); break;
	}
});

app.hears(/^(?:yep|yes|–¥–∞|Y)/i, (ctx) => {
	if (isIn1wordAnsExpecting()) {
		_isIn1wordAnsExpecting = false;
		lastQuestion.answer(true);
	}
});
app.hears(/^(?:no|nope|N|–Ω–µ—Ç|–Ω–µ-–∞)/i, (ctx) => {
	if (isIn1wordAnsExpecting()) {
		lastQuestion.answer(false);
	}
});

app.hears(/./, (ctx) => {
	console.log(ctx.from)
	if(!isVoiceVerboseMode) return;
	const name = ctx.update.message.from.first_name;
	say(`–≥–æ–≤–æ—Ä–∏—Ç ${ homemates.get(name, 'name') || name }: ${ ctx.match.input }`, ctx, true);
});

const startHomematesPresensePolling = () => {
	setInterval(reportHomematesPresenseChange, 1000 * 60 * 1);
};

const reportHomematesPresenseChange = async () => {
	if ((new Date()).getHours() < 9) return;
	console.log('poll homemates presense');
	const diff = await getHomematesPresenseChange();
	if (diff.length) {
		sendHomematesDiff(diff);
		onChange('home', 'presense', diff);
	}
};

const sendHomematesDiff = throttle((diff) => {
	console.log('diff', diff);
	app.telegram.sendMessage(VIGVAM_ID, 'üè†‚ÜòÔ∏é‚ÜñÔ∏é\n'
	+ diff.map(item => item.who + (item.before ? ' –≤–µ—Ä–Ω—É–ª—Å—è' : (Math.random() > .5 ? ' —É—à—ë–ª' : ' —Å–≤–∞–ª–∏–ª'))));
}, 1000 * 60 * 60);

const getHomematesPresenseChange = () => {
	const diff = whoAtHome().then(actualPresense => {
		const diff = Object.keys(homemates.list).filter(key => {
			return (homemates.get(key, 'presense') !== undefined && homemates.get(key, 'presense') !== null) && homemates.get(key, 'presense') !== actualPresense[key];
		})
		.map(key => {
			return { who: key, after: homemates.get(key, 'presense'), before: actualPresense[key] };
		});
		homemates.setAll('presense', actualPresense);
		return diff;
	});
	return diff;
};


app.startPolling();
startHomematesPresensePolling();
